"""
Shapefile exporter con file locking.
"""
import os
import shutil
import tempfile
import zipfile
import shapefile
from datetime import datetime
from typing import Optional
from django.contrib.gis.geos import GEOSGeometry
import logging

from apps.core.file_locking import file_lock, FileRegistry

logger = logging.getLogger(__name__)


class ShapefileExporter:
    """Exporta datos geoespaciales a Shapefile con file locking."""
    
    def __init__(self, output_dir: Optional[str] = None):
        self.output_dir = output_dir or 'data/exports/shapefiles'
        os.makedirs(self.output_dir, exist_ok=True)
    
    def export_layer(self, layer, filename: Optional[str] = None, 
                     user_id: Optional[int] = None) -> dict:
        """
        Exporta capa con file locking.
        
        Returns:
            dict con información del archivo generado
        """
        if filename is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{layer.name.replace(' ', '_')}_{timestamp}"
        
        # Ruta final
        zip_path = os.path.join(self.output_dir, f"{filename}.zip")
        
        # Verificar duplicado
        if os.path.exists(zip_path):
            import uuid
            filename = f"{filename}_{uuid.uuid4().hex[:8]}"
            zip_path = os.path.join(self.output_dir, f"{filename}.zip")
        
        logger.info(f"Exportando {layer.name} con file locking...")
        
        # LOCK el archivo durante la exportación
        with file_lock(zip_path, timeout=60):
            features = layer.features.filter(is_active=True)
            
            if not features.exists():
                raise ValueError(f"No hay features en {layer.name}")
            
            temp_dir = tempfile.mkdtemp(prefix='smgi_')
            shp_path = os.path.join(temp_dir, filename)
            
            try:
                w = shapefile.Writer(shp_path)
                
                first = features.first()
                geom = GEOSGeometry(first.geometry.json)
                
                if geom.geom_type == 'Point':
                    w.shapeType = shapefile.POINT
                elif geom.geom_type == 'LineString':
                    w.shapeType = shapefile.POLYLINE
                else:
                    w.shapeType = shapefile.POLYGON
                
                if first.properties:
                    for k, v in first.properties.items():
                        if isinstance(v, int):
                            w.field(k[:10], 'N', size=19)
                        elif isinstance(v, float):
                            w.field(k[:10], 'F', size=19, decimal=8)
                        else:
                            w.field(k[:10], 'C', size=254)
                w.field('feature_id', 'C', size=254)
                
                for f in features:
                    if not f.geometry:
                        continue
                    
                    g = GEOSGeometry(f.geometry.json)
                    
                    if g.geom_type == 'Point':
                        w.point(g.x, g.y)
                    elif g.geom_type == 'LineString':
                        w.line([list(g.coords)])
                    elif g.geom_type == 'Polygon':
                        w.poly([list(g[0].coords)])
                    
                    vals = []
                    if first.properties:
                        for k in first.properties.keys():
                            vals.append(f.properties.get(k, '') if f.properties else '')
                    vals.append(f.feature_id or '')
                    w.record(*vals)
                
                w.close()
                
                # Archivos auxiliares
                with open(f"{shp_path}.prj", 'w') as prj:
                    prj.write('GEOGCS["WGS84",DATUM["WGS_1984",SPHEROID["WGS84",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.0174532925199433]]')
                
                with open(f"{shp_path}.cpg", 'w') as cpg:
                    cpg.write('UTF-8')
                
                # Metadata
                metadata_content = f"""Shapefile Export Metadata
========================

Layer: {layer.name}
Description: {layer.description or 'N/A'}
Type: {layer.get_layer_type_display()}
Geometry: {layer.get_geometry_type_display() if layer.geometry_type else 'N/A'}
SRID: {layer.srid}
Features: {features.count()}
Exported: {datetime.now()}

Generated by: SMGI Backend
"""
                
                # Crear ZIP
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for ext in ['.shp', '.shx', '.dbf', '.prj', '.cpg']:
                        fp = f"{shp_path}{ext}"
                        if os.path.exists(fp):
                            zipf.write(fp, os.path.basename(fp))
                    
                    zipf.writestr(f"{filename}_metadata.txt", metadata_content)
                
                # Registrar en BD
                file_record = FileRegistry.register_file(
                    file_path=zip_path,
                    category='export',
                    user_id=user_id,
                    metadata={
                        'layer_id': layer.id,
                        'layer_name': layer.name,
                        'feature_count': features.count(),
                        'format': 'shapefile'
                    }
                )
                
                logger.info(f"Export completado: {zip_path}")
                
                return {
                    'success': True,
                    'file_path': zip_path,
                    'filename': os.path.basename(zip_path),
                    'size': os.path.getsize(zip_path),
                    'format': 'shapefile',
                    'features_count': features.count(),
                    'file_id': file_record.id
                }
                
            except Exception as e:
                logger.error(f"Error exportando: {e}")
                if os.path.exists(zip_path):
                    os.remove(zip_path)
                raise
                
            finally:
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
    
    def export_features(self, features, filename: str, crs: str = "EPSG:4326") -> dict:
        """Exporta un conjunto de features."""
        if features.exists():
            return self.export_layer(features.first().layer, filename)
        raise ValueError("No features to export")
    
    def export_dataset(self, dataset, filename: Optional[str] = None) -> dict:
        """Exporta un dataset completo."""
        if filename is None:
            filename = f"{dataset.name.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        temp_dir = tempfile.mkdtemp()
        try:
            exports = []
            for layer in dataset.layers.filter(is_active=True):
                result = self.export_layer(layer, f"{filename}_{layer.name.replace(' ', '_')}")
                exports.append(result)
            
            # Crear ZIP con todos los exports
            final_zip = os.path.join(self.output_dir, f"{filename}_complete.zip")
            with zipfile.ZipFile(final_zip, 'w') as zipf:
                for exp in exports:
                    zipf.write(exp['file_path'], os.path.basename(exp['file_path']))
            
            return {
                'success': True,
                'file_path': final_zip,
                'exports': exports
            }
        finally:
            shutil.rmtree(temp_dir, ignore_errors=True)
    
    def cleanup(self):
        """Limpia el directorio de salida."""
        if self.output_dir and os.path.exists(self.output_dir):
            shutil.rmtree(self.output_dir, ignore_errors=True)
